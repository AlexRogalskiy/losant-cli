#!/usr/bin/env node

const program = require('commander')
const c = require('chalk')
const losant = require('losant-rest')
const fs = require('fs')
const path = require('path')
const minimatch = require('minimatch')
const mkdirp = require('mkdirp')
const glob = require('glob')
const pad = require('pad')
const { spawn } = require('child_process')
const request = require('sync-request')
const FormData = require('form-data')
const { loadConfig, isFileNewer, loadLocalMeta, saveLocalMeta, 
  getLocalStatus, getRemoteStatus, checksum } = require('./lib/utils')

const log = console.log

program
  .description('Manage Losant Files from the command line')

program
  .command('download [pattern]')
  .option('-f, --force', 'force all changes by ignoring modification checking')
  .option('-c, --config <file>', 'config file to run the command with. (default: "losant.yml")')
  .option('-d, --dir <dir>', 'directory to run the command in. (default: current directory)')
  .option('--dry-run', 'display actions but do not perform them')
  .action((pattern, command) => {
    if (command.dir) {
      process.chdir(command.dir)
    }
    const config = loadConfig(command.config)
    const api = losant.createClient({ accessToken: config.apiToken })

    // log()
    api.files
      .get({ applicationId: config.applicationId })
      .then((files) => {
        const results = []
        let items = files.items
        const meta = loadLocalMeta('files') || {}
        let itemsSkipped = false
        // filter out files that don't match file pattern
        items = items.filter((file) => {
          if (file.type === 'directory') { return false }
          if (pattern) {
            if (minimatch(file.parentDirectory + file.name, pattern)) {
              return true
            }
            return false
          } else {
            return true
          }
        })
        // map files to id
        const filesById = {}
        items.forEach((item) => {
          filesById[item.id] = item
        })
        // grab the local status and map to ids
        const localStatus = getLocalStatus('files', '/**/*.*', 'files')
        const localStatusById = {}
        const newLocalFiles = new Set()
        localStatus.forEach((item) => {
          if (item.id) {
            localStatusById[item.id] = item
          } else {
            newLocalFiles.add(item.file)
          }
        })
        // iterate over remote status and perform the appropriate action
        const remoteStatus = getRemoteStatus('files', items, 'files${parentDirectory}${name}')
        remoteStatus.forEach((item) => {
          // if forcing the update ignore conflicts and local modifications
          if (!command.force) {
            if (item.status === 'unmodified') { return }
            if ((localStatusById[item.id] && localStatusById[item.id].status !== 'unmodified') || newLocalFiles.has(item.file)) {
              results.push({ action: 'conflict', file: item.file })
              return 
            }
          }
          if (item.status === 'deleted') {
            if (!command.dryRun) {
              if (fs.existsSync(item.file)) { 
                fs.unlinkSync(item.file) 
              }
              delete meta[item.file]
            }
            results.push({ action: 'deleted', file: item.file })
          } else {
            if (!command.dryRun) {
              const file = filesById[item.id]
              const mtime = new Date(item.remoteModTime)
              mkdirp.sync(path.dirname(item.file))
              const res = request('GET', file.url)
              if (res.statusCode !== 200) {
                throw new Error(`${item.file} (${res.statusCode}: ${file.url})`)
              }
              const body = res.getBody()
              fs.writeFileSync(item.file, res.getBody())
              meta[item.file] = {
                id: item.id,
                md5: checksum(body),
                remoteTime: mtime.getTime(),
                localTime: new Date().getTime()
              }
            }
            results.push({ action: 'downloaded', file: item.file })
          }
        })
        saveLocalMeta('files', meta)
        // display results
        if (results.length > 0) {
          command.dryRun ? log('Downloading (DRY RUN):') : log('Downloading:')
          results.forEach((result) => {
            if (result.action === 'unmodified') { return }
            let status = c.gray(result.action)
            if (result.action === 'downloaded') { status = c.green(result.action) }
            else if (result.action === 'deleted') { status = c.yellow(result.action) }
            else if (result.action === 'conflict') { status = c.red(result.action) }
            log(`   ${pad(status, 13)}\t${result.file}`)
          })
        } else {
          log('All files are up to date')
        }
        // log()
      })
      .catch((e) => {
        log(`${c.red('Error')} failed to download: ${c.bold(e.message)}`)
        // console.log(e)
      })

  })

program
  .command('upload [pattern]')
  .option('-f, --force', 'force all changes by ignoring modification checking')
  .option('-c, --config <file>', 'config file to run the command with. (default: "losant.yml")')
  .option('-d, --dir <dir>', 'directory to run the command in. (default: current directory)')
  .option('--dry-run', 'display actions but do not perform them')
  .action((pattern, command) => {
    if (command.dir) {
      process.chdir(command.dir)
    }
    try {
      const config = loadConfig(command.config)
      const api = losant.createClient({ accessToken: config.apiToken })
      // log()
      const meta = loadLocalMeta('files') || {}
      api.files
        .get({ applicationId: config.applicationId })
        .then((files) => {
          let items = files.items
          // grab remote status and map to file
          const remoteStatus = getRemoteStatus('files', items, 'files${parentDirectory}${name}', 'type')
          const remoteStatusById = {}
          remoteStatus.forEach((item) => {
            if (item.id) {
              remoteStatusById[item.id] = item
            }
          })
          // iterate over local status and perform the appropriate action
          const localStatus = getLocalStatus('files', '/' + (pattern || '**/*'), 'files')
          return Promise.all(localStatus.map((item) => {
            // if forcing the update ignore conflicts and remote modifications
            if (!command.force) {
              if (item.status === 'unmodified') { return }
              if ((remoteStatusById[item.id] && remoteStatusById[item.id].status !== 'unmodified')) {
                return Promise.resolve({ action: 'conflict', file: item.file })
              }
            }
            if (item.status === 'deleted') {
              if (!command.dryRun) {
                return api.files
                  .delete({ applicationId: config.applicationId,  fileId: item.id })
                  .then((view) => {
                    delete meta[item.file]
                    return Promise.resolve({ action: 'deleted', file: item.file })
                  })
              }
              return Promise.resolve({ action: 'deleted', file: item.file })
            } else {
              if (!command.dryRun) {
                let action
                const body = fs.readFileSync(item.file)
                if (item.id) {
                  action = api.file
                    .patch({ 
                      applicationId: config.applicationId, 
                      fileId: item.id, 
                      file:  { 
                        fileSize: item.size
                      } 
                    })
                } else {
                  action = api.files
                    .post({
                      applicationId: config.applicationId,
                      file: { 
                        name: item.name, 
                        parentDirectory: path.dirname(item.file),
                        type: 'file',
                        fileSize: item.size 
                      }
                    })
                }
                return action.then((file) => {
                  return new Promise((resolve, reject) => {
                    const fd = new FormData()
                    Object.keys(file.upload.fields).forEach((key) => {
                      if (key !== 'bucket') {
                        fd.append(key, file.upload.fields[key])
                      }
                    })
                    fd.append('file', body)
                    fd.submit(file.upload.url, (err, res) => {
                      if (err) {
                        return reject(err)
                      }
                      return resolve(file)
                    })
                  })
                }).then((file) => {
                  const mtime = new Date(file.lastUpdated)
                  //fs.writeFileSync(item.file, body)
                  meta[item.file] = {
                    id: item.id,
                    md5: checksum(body),
                    remoteTime: mtime.getTime(),
                    localTime: item.localModTime * 1000
                  }
                  return Promise.resolve({ action: 'uploaded', file: item.file })
                })
              }
              return Promise.resolve({ action: 'uploaded', file: item.file })
            }
          }))
        })
        .then((results) => {
          saveLocalMeta('files', meta)
          // display results
          results = results.filter((result) => {
            return result
          })
          if (results.length > 0) {
            command.dryRun ? log('Uploading (DRY RUN):') : log('Uploading:')
            results.forEach((result) => {
              if (!result || result.action === 'unmodified') { return }
              let status = c.gray(result.action)
              if (result.action === 'uploaded') { status = c.green(result.action) }
              else if (result.action === 'deleted') { status = c.yellow(result.action) }
              else if (result.action === 'conflict') { status = c.red(result.action) }
              log(`   ${pad(status, 13)}\t${result.file}`)
            })
          } else {
            log('All files are up to date')
          }
          // log()
        })
        .catch((e) => {
          log(`${c.red('Error')} failed to upload: ${c.bold(e.message)}`)
        })
    } catch (err) {
      log(`${c.red('Error')} ${err.message}`)
      process.exit(1)
    }
  })

program
  .command('status')
  .option('-c, --config <file>', 'config file to run the command with')
  .option('-d, --dir <dir>', 'directory to run the command in. (default current directory)')
  .option('-r, --remote', 'show remote file status')
  .action((command) => {
    if (command.dir) {
      process.chdir(command.dir)
    }
    try {
      const config = loadConfig(command.config)
      const api = losant.createClient({ accessToken: config.apiToken })

      api.files
        .get({ applicationId: config.applicationId })
        .then((files) => {
          // log()
          if (command.remote) {
            // remove directories
            files.items = files.items.filter((item) => {
              return item.type === 'file'
            })
            const remoteStatus = getRemoteStatus('files', files.items, 'files${parentDirectory}${name}')
            if (remoteStatus.length === 0) {
              log('No remote files found')
            } else {
              log('Remote file status:')
            }
            remoteStatus.forEach((item) => {
              let status = c.gray(item.status)
              if (item.status === 'added') { status = c.green(item.status) }
              else if (item.status === 'modified') { status = c.yellow(item.status) }
              else if (item.status === 'deleted') { status = c.red(item.status) }
              log(`   ${pad(status, 10)}\t${item.file}`)
            })
          } else {
            const localStatus = getLocalStatus('files', '/**/*.*', 'files')
            if (localStatus.length === 0) {
              log('No local files found')
            } else {
              log('Local file status:')
            }
            localStatus.forEach((item) => {
              let status = c.gray(item.status)
              if (item.status === 'added') { status = c.green(item.status) }
              else if (item.status === 'modified') { status = c.yellow(item.status) }
              else if (item.status === 'deleted') { status = c.red(item.status) }
              log(`   ${pad(status, 10)}\t${item.file}`)
            })
          }
          // log()
        })
        .catch((e) => {
          log(`${c.red('Error')} failed show status: ${c.bold(e.message)}`)
        })
    } catch (err) {
      log(`${c.red('Error')} ${err.message}`)
      process.exit(1)
    }
  })

program
  .command('watch')
  .option('-c, --config <file>', 'config file to run the command with')
  .option('-d, --dir <dir>', 'directory to run the command in. (default current directory)')
  .action((command) => {
    if (command.dir) {
      process.chdir(command.dir)
    }
    fs.watch('files', { recursive: true }, (eventType, filename) => {
      if (eventType === 'change') {
        if (filename) {
          const cmd = process.argv[0]
          const args = process.argv.slice(1)
          args[1] = 'upload'
          args.push(`${filename.slice(0, -4)}`)
          const options = {
            cwd: process.cwd(),
            stdio: [process.stdin, process.stdout, 'pipe']
          }
          const upload = spawn(cmd, args, options)
          upload.on('error', (err) => {
            log(`${c.red('Error')} ${err.message}`)
            process.exit(1)
          })
        }
      }
    })
  })

program.on('--help', () => {
  log('')
  log('  Examples:')
  log('')
  log('    Download all files')
  log('     $ losant files download \n')
  log('    Download files in images directory')
  log('     $ losant files download images/* \n')
  log('    Force a download of all files overwriting local modifications')
  log('     $ losant files download -f \n')
  log('    Check local modification status')
  log('     $ losant files status \n')
  log('    Check remote modification status')
  log('     $ losant files status -r \n')
  log('    Upload all files')
  log('     $ losant files upload \n')
  log('    Upload files in images directory')
  log('     $ losant files upload images/* \n')
  log('    Force an upload of all files overwriting remote modifications')
  log('     $ losant files upload -f \n')
  log('')
})  
  
program.parse(process.argv)
