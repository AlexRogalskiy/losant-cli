#!/usr/bin/env node

const program = require('commander')
const c = require('chalk')
const losant = require('losant-rest')
const fs = require('fs')
const path = require('path')
const minimatch = require('minimatch')
const mkdirp = require('mkdirp')
const glob = require('glob')
const pad = require('pad')
const { spawn } = require('child_process')
const { loadConfig, isFileNewer, loadLocalMeta, saveLocalMeta, 
  getLocalStatus, getRemoteStatus, checksum } = require('./lib/utils')

const log = console.log

program
  .description('Manage Losant Experience Views from the command line')

program
  .command('download [pattern]')
  .option('-f, --force', 'force all changes by ignoring modification checking')
  .option('-c, --config <file>', 'config file to run the command with. (default: "losant.yml")')
  .option('-d, --dir <dir>', 'directory to run the command in. (default: current directory)')
  .option('--dry-run', 'display actions but do not perform them')
  .action((pattern, command) => {
    if (command.dir) {
      process.chdir(command.dir)
    }
    const config = loadConfig(command.config)
    const api = losant.createClient({ accessToken: config.apiToken })

    // log()
    api.experienceViews
      .get({ applicationId: config.applicationId })
      .then((views) => {
        const results = []
        let items = views.items
        const meta = loadLocalMeta('views') || {}
        let itemsSkipped = false
        // filter out views that don't match file pattern
        if (pattern) {
          items = items.filter((view) => {
            if (view.viewType + 's' === type && minimatch(view.name, pattern)) {
              return true
            }
            return false
          })
        }
        // map views to id
        const viewsById = {}
        items.forEach((item) => {
          viewsById[item.id] = item
        })
        // grab the local status and map to ids
        const localStatus = getLocalStatus('views', '/**/*.hbs', 'views')
        const localStatusById = {}
        const newLocalFiles = new Set()
        localStatus.forEach((item) => {
          if (item.id) {
            localStatusById[item.id] = item
          } else {
            newLocalFiles.add(item.file)
          }
        })
        // iterate over remote status and perform the appropriate action
        const remoteStatus = getRemoteStatus('.hbs', 'views', items, 'viewType', 'body')
        remoteStatus.forEach((item) => {
          // if forcing the update ignore conflicts and local modifications
          if (!command.force) {
            if (item.status === 'unmodified') { return }
            if ((localStatusById[item.id] && localStatusById[item.id].status !== 'unmodified') || newLocalFiles.has(item.file)) {
              results.push({ action: 'conflict', file: item.file })
              return 
            }
          }
          if (item.status === 'deleted') {
            if (!command.dryRun) {
              if (fs.existsSync(item.file)) { 
                fs.unlinkSync(item.file) 
              }
              delete meta[item.file]
            }
            results.push({ action: 'deleted', file: item.file })
          } else {
            if (!command.dryRun) {
              const view = viewsById[item.id]
              const mtime = new Date(item.remoteModTime)
              mkdirp.sync(path.dirname(item.file))
              fs.writeFileSync(item.file, view.body)
              fs.utimesSync(item.file, mtime, mtime)
              meta[item.file] = {
                id: item.id,
                md5: checksum(view.body),
                time: item.remoteModTime
              }
            }
            results.push({ action: 'downloaded', file: item.file })
          }
        })
        saveLocalMeta('views', meta)
        // display results
        if (results.length > 0) {
          command.dryRun ? log('Downloading (DRY RUN):') : log('Downloading:')
          results.forEach((result) => {
            if (result.action === 'unmodified') { return }
            let status = c.gray(result.action)
            if (result.action === 'downloaded') { status = c.green(result.action) }
            else if (result.action === 'deleted') { status = c.yellow(result.action) }
            else if (result.action === 'conflict') { status = c.red(result.action) }
            log(`   ${pad(status, 13)}\t${result.file}`)
          })
        } else {
          log('All views are up to date')
        }
        // log()
      })
      .catch((e) => {
        log(`${c.red('Error')} failed to download: ${c.bold(e.message)}`)
        console.log(e)
      })

  })

program
  .command('upload [pattern]')
  .option('-f, --force', 'force all changes by ignoring modification checking')
  .option('-c, --config <file>', 'config file to run the command with. (default: "losant.yml")')
  .option('-d, --dir <dir>', 'directory to run the command in. (default: current directory)')
  .option('--dry-run', 'display actions but do not perform them')
  .action((pattern, command) => {
    if (command.dir) {
      process.chdir(command.dir)
    }
    try {
      const config = loadConfig(command.config)
      const api = losant.createClient({ accessToken: config.apiToken })
      // log()
      const meta = loadLocalMeta('views') || {}
      api.experienceViews
        .get({ applicationId: config.applicationId })
        .then((views) => {
          let items = views.items
          // grab remote status and map to file
          const remoteStatus = getRemoteStatus('.hbs', 'views', items, 'viewType', 'body')
          const remoteStatusById = {}
          remoteStatus.forEach((item) => {
            if (item.id) {
              remoteStatusById[item.id] = item
            }
          })
          // iterate over local status and perform the appropriate action
          const localStatus = getLocalStatus('views', '/' + (pattern || '**/*') + '.hbs', 'views')
          return Promise.all(localStatus.map((item) => {
            // if forcing the update ignore conflicts and remote modifications
            if (!command.force) {
              if (item.status === 'unmodified') { return }
              if ((remoteStatusById[item.id] && remoteStatusById[item.id].status !== 'unmodified')) {
                return Promise.resolve({ action: 'conflict', file: item.file })
              }
            }
            if (item.status === 'deleted') {
              if (!command.dryRun) {
                return api.experienceView
                  .delete({ applicationId: config.applicationId,  experienceViewId: item.id })
                  .then((view) => {
                    delete meta[item.file]
                    return Promise.resolve({ action: 'deleted', file: item.file })
                  })
              }
              return Promise.resolve({ action: 'deleted', file: item.file })
            } else {
              if (!command.dryRun) {
                let action
                const body = fs.readFileSync(item.file)
                if (item.id) {
                  action = api.experienceView
                    .patch({ 
                      applicationId: config.applicationId, 
                      experienceViewId: item.id, 
                      experienceView:  { body: body.toString() } 
                    })
                } else {
                  action = api.experienceViews
                    .post({
                      applicationId: config.applicationId,
                      experienceViewId: item.id,
                      experienceView: { 
                        viewType: item.type, 
                        name: item.name,
                        body: body.toString() 
                      }
                    })
                }
                return action.then((view) => {
                  const mtime = new Date(view.lastUpdated)
                  mkdirp.sync(path.dirname(item.file))
                  fs.writeFileSync(item.file, view.body)
                  fs.utimesSync(item.file, mtime, mtime)
                  meta[item.file] = {
                    id: view.id,
                    md5: checksum(view.body),
                    time: view.lastUpdated
                  }
                  return Promise.resolve({ action: 'uploaded', file: item.file })
                })
              }
              return Promise.resolve({ action: 'uploaded', file: item.file })
            }
          }))
        })
        .then((results) => {
          saveLocalMeta('views', meta)
          // display results
          results = results.filter((result) => {
            return result
          })
          if (results.length > 0) {
            command.dryRun ? log('Uploading (DRY RUN):') : log('Uploading:')
            results.forEach((result) => {
              if (!result || result.action === 'unmodified') { return }
              let status = c.gray(result.action)
              if (result.action === 'uploaded') { status = c.green(result.action) }
              else if (result.action === 'deleted') { status = c.yellow(result.action) }
              else if (result.action === 'conflict') { status = c.red(result.action) }
              log(`   ${pad(status, 13)}\t${result.file}`)
            })
          } else {
            log('All views are up to date')
          }
          // log()
        })
        .catch((e) => {
          log(`${c.red('Error')} failed to upload: ${c.bold(e.message)}`)
        })
    } catch (err) {
      log(`${c.red('Error')} ${err.message}`)
      process.exit(1)
    }
  })

program
  .command('status')
  .option('-c, --config <file>', 'config file to run the command with')
  .option('-d, --dir <dir>', 'directory to run the command in. (default current directory)')
  .option('-r, --remote', 'show remote file status')
  .action((command) => {
    if (command.dir) {
      process.chdir(command.dir)
    }
    try {
      const config = loadConfig(command.config)
      const api = losant.createClient({ accessToken: config.apiToken })

      api.experienceViews
        .get({ applicationId: config.applicationId })
        .then((views) => {
          // log()
          if (command.remote) {
            const remoteStatus = getRemoteStatus('.hbs', 'views', views.items, 'viewType', 'body')
            if (remoteStatus.length === 0) {
              log('No remote views found')
            } else {
              log('Remote file status:')
            }
            remoteStatus.forEach((item) => {
              let status = c.gray(item.status)
              if (item.status === 'added') { status = c.green(item.status) }
              else if (item.status === 'modified') { status = c.yellow(item.status) }
              else if (item.status === 'deleted') { status = c.red(item.status) }
              log(`   ${pad(status, 10)}\t${item.file}`)
            })
          } else {
            const localStatus = getLocalStatus('views', '/**/*.hbs', 'views')
            if (localStatus.length === 0) {
              log('No local views found')
            } else {
              log('Local file status:')
            }
            localStatus.forEach((item) => {
              let status = c.gray(item.status)
              if (item.status === 'added') { status = c.green(item.status) }
              else if (item.status === 'modified') { status = c.yellow(item.status) }
              else if (item.status === 'deleted') { status = c.red(item.status) }
              log(`   ${pad(status, 10)}\t${item.file}`)
            })
          }
          // log()
        })
        .catch((e) => {
          log(`${c.red('Error')} failed show status: ${c.bold(e.message)}`)
        })
    } catch (err) {
      log(`${c.red('Error')} ${err.message}`)
      process.exit(1)
    }
  })

program
  .command('watch')
  .option('-c, --config <file>', 'config file to run the command with')
  .option('-d, --dir <dir>', 'directory to run the command in. (default current directory)')
  .action((command) => {
    if (command.dir) {
      process.chdir(command.dir)
    }
    fs.watch('views', { recursive: true }, (eventType, filename) => {
      if (eventType === 'change') {
        if (filename) {
          const cmd = process.argv[0]
          const args = process.argv.slice(1)
          args[1] = 'upload'
          args.push(`${filename.slice(0, -4)}`)
          const options = {
            cwd: process.cwd(),
            stdio: [process.stdin, process.stdout, 'pipe']
          }
          const upload = spawn(cmd, args, options)
          upload.on('error', (err) => {
            log(`${c.red('Error')} ${err.message}`)
            process.exit(1)
          })
        }
      }
    })
  })

program.on('--help', () => {
  log('')
  log('  Examples:')
  log('')
  log('    Download all views')
  log('     $ losant views download \n')
  log('    Download component views')
  log('     $ losant views download components/* \n')
  log('    Force a download of all views overwriting local modifications')
  log('     $ losant views download -f \n')
  log('    Check local modification status')
  log('     $ losant views status \n')
  log('    Check remote modification status')
  log('     $ losant views status -r \n')
  log('    Upload all view')
  log('     $ losant views upload \n')
  log('    Upload component view')
  log('     $ losant views upload components/* \n')
  log('    Force an upload of all views overwriting remote modifications')
  log('     $ losant views upload -f \n')
  log('')
})  
  
program.parse(process.argv)
